# 美团2024届秋招第四场笔试【技术】



是鼠鼠第二次进行美团笔试，第一次笔试一题未A，这次好一点点，A了一道，但还是必挂，其他人都至少A4道的啊啊啊啊啊

多刷题多刷题



题型：5道编程题

类型：软件开发岗

来源：https://mp.weixin.qq.com/s/j9gIAqjW7JqNpGgRUo9XvQ



# 第一题  小美的升序数组

## 题目描述

给定一个大小为n的数组a，请你判断一个数组是否满足以下条件：

1. 数组严格升序，即`a<a1<a2<...<an`
2. 对于1<=i<=n-1，我们定义`bi=ai+1-ai`，则数组b严格降序，即`b1>b2>...>bn-1`。

**输入描述**

第一行输入一个正整数n，代表数组的大小。

第二行输入n个正整数ai，代表给定的数组。

````
3<=n<=10^5

1<=ai<=10^9
````



**输出描述**

若满足给定的两个条件，则输出 Yes。否则输出 No。



**示例1**

**输入**

```
3
1 3 4
```

**输出**

```
Yes
```

**示例2**

**输入**

```
3
1 3 3
```

**输出**

```
No
```

11



## 正确题解



````java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] an = new int[n];
        for (int i = 0; i < n; i++) {
            an[i] = sc.nextInt();
        }


        int[] bn = new int[n]; //bn递减 an递增
        int start = 0;
        for (int i = 1; i < n - 1; i++) {
            if (an[i] <= an[i - 1]) {
                System.out.println("NO");
                return;
            } else {
                bn[i] = an[i+1] - an[i];
                if (i != 1) {
                    if (bn[i] >= bn[i - 1]) {
                        System.out.println("No");
                        return;
                    }
                }

            }
        }
        System.out.println("Yes");
    }
}
````



## 其他题解



````java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];

        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        boolean strictlyAscending = true;
        boolean strictlyDescending = true;

        for (int i = 0; i < n - 1; i++) {
            if (arr[i] >= arr[i + 1]) {
                strictlyAscending = false;
                break;
            }
        }

        for (int i = 0; i < n - 2; i++) {
            if (arr[i + 1] - arr[i] <= arr[i + 2] - arr[i + 1]) {
                strictlyDescending = false;
                break;
            }
        }

        if (strictlyAscending && strictlyDescending) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }
    }
}
````







`````java
import java.util.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        int n = in.nextInt();
        int[] nums = new int[n];
        int max = Integer.MIN_VALUE;
        for(int i = 0; i < n; i++) {
            nums[i] = in.nextInt();
            if(nums[i] > max) {
                max = nums[i]; //得到数组最大值
            }
        }

        int first = nums[0]; //第一个数
        int count1 = 0, count2 = 0;
        while(first <= max) {
            first *= 2;
            count1++;
        }

        count2 = travel(first,max,0);

        int count = count1 > count2 ? count2 : count1;
        System.out.println(count);
    }

    public static int travel(int first, int max,int count2) {
        int first1 = travel(first * 2, max,count2);
        int first2 = travel(first, max / 2, count2);
        count2++;
        
        if(first1 > max || first2 > max) {
            return first > first2 ? first2 : first1;
        }
        return max;
    }



}
`````





# 第二题 小美的子序列

## 题目描述

小美在n行m列的本子上写了许多字母，她会在每一行中找出一个字母，然后组成一个字符串。

小美想知道，组成的字符串中是否存在至少一个字符串包含 "meituan" 子序列。

**输入描述**

第一行输入2个整数n,m(1<=n,m<=1000) 。

接下来n行，每行输入一个长度为m的字符串表示小美写下的字母。

**输出描述**

若存在至少一个字符串包含 "meituan" 子序列，则输出 "YES"，否则输出 "NO"。



**示例1**

**输入**

```
3 3
abc
def
ghi
```

**输出**

```
NO
```

**说明**

显然并不能找到meituan子序列。



**示例2**

**输入**

```
8 2
nm
ex
it
td
ul
qu
ac
nt
```

**输出**

```
YES
```

**说明**

```
第1行选择第2个字母。
第2行选择第1个字母。
第3行选择第1个字母。
第4行选择第1个字母。
第5行选择第2个字母。
第6行选择第2个字母。
第7行选择第1个字母。
第8行选择第1个字母。
组成字符串"meitluan"，其中存在"meituan"子序列。
当然，第6行选第1个字母且第5行选第1个字母组成的字符串"meituqan"中也存在"meituan"子序列。
```



## 解题思路

思路：用0~6代表meituan七个字母，用ext[i][j]记录字母i是否存在第j行，然后用dp[i][j]表示前i行是否存在合法的字母0~j组成的字串。 随后递推求解dp即可，若第i行存在字母j，则dp[i][j]=dp[i-1][j]||dp[i-1][j-1]（不使用第i行的字母j||使用第i行的字母j）； 否则dp[i][j]=dp[i-1][j]（不使用第i行的字母j）。



## 正确题解



```java

```





![image-20230902221834898](https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/2023-9/202309022218991.png)

![](https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/2023-9/202309022218670.png)

11









# 第三题  小美的数组

## 题目描述

小美拿到了一个数组。她每次可以进行如下操作之一：

1. 选择一个元素，使其乘以 2。
2. 选择一个元素，使其除以 2，向下取整。

小美希望第一个元素变成所有元素的最大值。请你判断小美最少需要操作多少次？

**输入描述**

第一行输入一个正整数n，代表数组的大小。 第二行输入n个正整数ai，代表小美拿到的数组。

`````
1<=n<=10^5

1<=ai<=10^9
`````



**输出描述**

输出最小操作次数。



**示例1**

**输入**

```
4
1 2 3 4
```

**输出**

```
2
```

**说明**

将第一个元素乘两次 2 即可。







![image-20230902221910236](https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/2023-9/202309022219275.png)



## 解题思路

思路：暴力即可，第一个数字至多乘32次2，那么对每个乘好的第一个数字分别计算后n-1个数字需要除多少次，时间复杂度O(n(log(INT_MAX/n))。



## 正确题解



````java
import java.util.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        int n = in.nextInt();
        int[] nums = new int[n];
        int max = Integer.MIN_VALUE;
        for(int i = 0; i < n; i++) {
            nums[i] = in.nextInt();
            if(nums[i] > max) {
                max = nums[i]; //得到数组最大值
            }
        }

        int first = nums[0]; //第一个数
        int count1 = 0, count2 = 0;
        while(first <= max) {
            first *= 2;
            count1++;
        }

        count2 = travel(first,max,0);

        int count = count1 > count2 ? count2 : count1;
        System.out.println(count);
    }

    public static int travel(int first, int max,int count2) {
        int first1 = travel(first * 2, max,count2);
        int first2 = travel(first, max / 2, count2);
        count2++;
        
        if(first1 > max || first2 > max) {
            return first > first2 ? first2 : first1;
        }
        return max;
    }



}
````





# 第四题 小美的元素删除

## 题目描述

小美有一个数组，她希望删除k个元素，使得剩余的元素两两之间互为倍数关系。你能告诉小美有多少种删除方案吗？

由于答案过大，请对10^9+7模。

**输入描述**

第一行输入两个整数n,k(1<=k<=n<=10^3)表示数组长度，删除的元素数量。

第二行输入n,k个整数表示数组a(1<=ai<=10^9)。

保证给定的数组中不存在两个相等元素。

**输出描述**

输出一个整数表示答案。



**示例1**

**输入**

```
6 4
1 4 2 3 6 7
```

**输出**

```
8
```

**说明**

方案1：删除1,4,2,7。

方案2：删除1,4,3,7。

方案3：删除1,3,6,7。

方案4：删除4,2,3,6。

方案5：删除4,2,3,7。

方案6：删除4,2,6,7。

方案7：删除4,3,6,7。

方案8：删除2,3,6,7。







![image-20230902221925826](https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/2023-9/202309022219862.png)

![image-20230902221947700](https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/2023-9/202309022219734.png)



## 解题思路

思路：首先将数组从小到大排序，然后用yueshu[i]这个vector容器记录所有a[i]约数的index，该过程时间复杂度为 O(nlogn+n^2)； 随后用dp[i][j]表示以第i个数字结尾的长度为j的两两有倍数关系的子数组个数，dp[i][j]为所有dp[i的约数索引] [j-1]之和，该过程时间复杂度最大为 O(n(n-k)*(平均约数个数))； 最后的答案就是所有dp[i] [n-k]之和。





## 正确题解







# 第五题